package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type d3struct struct {
	vpc       string
	subnet    string
	instances []string
}

func main() {
	results := getdata()
	var r cloudTree
	json.Unmarshal(results, &r)

	d3data := make(map[string]map[string][]string)
	for _, elid := range r.Reservations {

		if d3data[elid.Instances[0].VpcID][elid.Instances[0].SubnetID] == nil {
			d3data[elid.Instances[0].VpcID] = make(map[string][]string)
		} else if d3data[elid.Instances[0].ImageID][elid.Instances[0].VpcID] == nil {
			d3data[elid.Instances[0].ImageID] = make(map[string][]string)
		}

		d3data[elid.Instances[0].VpcID][elid.Instances[0].SubnetID] =
			append(d3data[elid.Instances[0].VpcID][elid.Instances[0].SubnetID], elid.Instances[0].InstanceID)
		//d3data[elid.Instances[0].ImageID][elid.Instances[0].VpcID] =
		//			append(d3data[elid.Instances[0].ImageID][elid.Instances[0].VpcID], elid.Instances[0].ImageID)
	}

	for k, v := range d3data {

		for kk := range v {

			Bill := &d3struct{
				vpc:       k,
				subnet:    kk,
				instances: v[kk],
			}
			fmt.Println(*Bill)
		}

	}
}

func getdata() []byte {
	var jsonStr []byte

	url := "http://localhost:8080/describe-instances.json"
	req, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonStr))
	req.Header.Set("Content-Type", "application/json")
	if err != nil {
		log.Fatal("Die: ", err)
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	return body
}

type cloudTree struct {
	Reservations []struct {
		OwnerID       string        `json:"OwnerId"`
		ReservationID string        `json:"ReservationId"`
		Groups        []interface{} `json:"Groups"`
		Instances     []struct {
			Monitoring struct {
				State string `json:"State"`
			} `json:"Monitoring"`
			PublicDNSName string `json:"PublicDnsName"`
			State         struct {
				Code int    `json:"Code"`
				Name string `json:"Name"`
			} `json:"State"`
			EbsOptimized          bool          `json:"EbsOptimized"`
			LaunchTime            time.Time     `json:"LaunchTime"`
			PublicIPAddress       string        `json:"PublicIpAddress"`
			PrivateIPAddress      string        `json:"PrivateIpAddress"`
			ProductCodes          []interface{} `json:"ProductCodes"`
			VpcID                 string        `json:"VpcId"`
			StateTransitionReason string        `json:"StateTransitionReason"`
			InstanceID            string        `json:"InstanceId"`
			ImageID               string        `json:"ImageId"`
			PrivateDNSName        string        `json:"PrivateDnsName"`
			KeyName               string        `json:"KeyName"`
			SecurityGroups        []struct {
				GroupName string `json:"GroupName"`
				GroupID   string `json:"GroupId"`
			} `json:"SecurityGroups"`
			ClientToken       string `json:"ClientToken"`
			SubnetID          string `json:"SubnetId"`
			InstanceType      string `json:"InstanceType"`
			NetworkInterfaces []struct {
				Status          string `json:"Status"`
				MacAddress      string `json:"MacAddress"`
				SourceDestCheck bool   `json:"SourceDestCheck"`
				VpcID           string `json:"VpcId"`
				Description     string `json:"Description"`
				Association     struct {
					PublicIP      string `json:"PublicIp"`
					PublicDNSName string `json:"PublicDnsName"`
					IPOwnerID     string `json:"IpOwnerId"`
				} `json:"Association"`
				NetworkInterfaceID string `json:"NetworkInterfaceId"`
				PrivateIPAddresses []struct {
					PrivateDNSName string `json:"PrivateDnsName"`
					Association    struct {
						PublicIP      string `json:"PublicIp"`
						PublicDNSName string `json:"PublicDnsName"`
						IPOwnerID     string `json:"IpOwnerId"`
					} `json:"Association"`
					Primary          bool   `json:"Primary"`
					PrivateIPAddress string `json:"PrivateIpAddress"`
				} `json:"PrivateIpAddresses"`
				PrivateDNSName string `json:"PrivateDnsName"`
				Attachment     struct {
					Status              string    `json:"Status"`
					DeviceIndex         int       `json:"DeviceIndex"`
					DeleteOnTermination bool      `json:"DeleteOnTermination"`
					AttachmentID        string    `json:"AttachmentId"`
					AttachTime          time.Time `json:"AttachTime"`
				} `json:"Attachment"`
				Groups []struct {
					GroupName string `json:"GroupName"`
					GroupID   string `json:"GroupId"`
				} `json:"Groups"`
				SubnetID         string `json:"SubnetId"`
				OwnerID          string `json:"OwnerId"`
				PrivateIPAddress string `json:"PrivateIpAddress"`
			} `json:"NetworkInterfaces"`
			SourceDestCheck bool `json:"SourceDestCheck"`
			Placement       struct {
				Tenancy          string `json:"Tenancy"`
				GroupName        string `json:"GroupName"`
				AvailabilityZone string `json:"AvailabilityZone"`
			} `json:"Placement"`
			Hypervisor          string `json:"Hypervisor"`
			BlockDeviceMappings []struct {
				DeviceName string `json:"DeviceName"`
				Ebs        struct {
					Status              string    `json:"Status"`
					DeleteOnTermination bool      `json:"DeleteOnTermination"`
					VolumeID            string    `json:"VolumeId"`
					AttachTime          time.Time `json:"AttachTime"`
				} `json:"Ebs"`
			} `json:"BlockDeviceMappings"`
			Architecture       string `json:"Architecture"`
			RootDeviceType     string `json:"RootDeviceType"`
			RootDeviceName     string `json:"RootDeviceName"`
			VirtualizationType string `json:"VirtualizationType"`
			Tags               []struct {
				Value string `json:"Value"`
				Key   string `json:"Key"`
			} `json:"Tags"`
			AmiLaunchIndex int `json:"AmiLaunchIndex"`
		} `json:"Instances"`
	} `json:"Reservations"`
}
